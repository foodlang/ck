// kept for reference

using System;
using System.Diagnostics.Contracts;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json.Serialization;
using ck.Semantics;
using ck.Semantics.Type;
using ck.Semantics.Tree;
using ck.Semantics.Tree.Expressions;
using ck.Semantics.Tree.Scopes;
using ck.Semantics.Tree.Statements;
using ck.Syntax;

namespace ck.Output;

/// <summary>
/// x86-64 generator using a stack machine (push/pop)
/// </summary>
public sealed class Gen_stackx8664
{
    public string GetTotal() => _string_pool_output.ToString() + "\n" + _output.ToString();

    public Gen_stackx8664(FreeTree program)
    {
        ProgramTree = program;
    }

    /// <summary>
    /// Generates the program.
    /// </summary>
    public void GenerateProgram()
    {
        // Generating function names
        foreach (var func in ProgramTree)
        {
            if (func is not FunctionTree f)
                continue;
            _ = GetFunctionName(f);
        }

        // Generating the functions
        foreach (var func in ProgramTree)
        {
            if (func is not FunctionTree f)
                continue;
            EmitFunction(f);
        }
    }

    // =====================================================================

    private const int NeedValue = 0;
    private const int NeedAddress = 1;

    /// <summary>
    /// A program tree.
    /// </summary>
    private readonly FreeTree ProgramTree;

    /// <summary>
    /// The output buffer.
    /// </summary>
    private readonly StringBuilder _output = new();

    /// <summary>
    /// The output for literal strings.
    /// </summary>
    private readonly StringBuilder _string_pool_output = new();

    /// <summary>
    /// The first available const string id.
    /// </summary>
    private int _first_available_conststr_id = 0;

    /// <summary>
    /// A local label.
    /// </summary>
    private int _first_available_local_label = 0;

    /// <summary>
    /// Emits an instruction to the output buffer.
    /// </summary>
    /// <param name="name">The instruction</param>
    private void Emit(string instruction) => _output.AppendLine("\t" + instruction);

    // =====================================================================

    /// <summary>
    /// Mangled internal and public name table
    /// </summary>
    private readonly List<(string Unmangled, Source? Internal, string Mangled)> _mangled_names = new();

    private string? GetMangledName(string name, Source? internal_to = null)
    {
        foreach (var mangled_name in _mangled_names)
            if (mangled_name.Unmangled == name && (mangled_name.Internal != null ? mangled_name.Internal == internal_to : true))
                return mangled_name.Mangled;

        return null;
    }

    private bool InternalBearsName(string name)
    {
        foreach (var mangled_name in _mangled_names)
            if (mangled_name.Unmangled == name)
                return mangled_name.Internal != null;
        throw new IndexOutOfRangeException();
    }

    private void SetMangledName(string name, Source? internal_to, string mangled)
    {
        if (GetMangledName(name, internal_to) != null)
            throw new InvalidOperationException();
        _mangled_names.Add((name, internal_to, mangled));
    }

    /// <summary>
    /// Gets the name of a global symbol.
    /// </summary>
    private string GetGlobalName(ScopeTree.SymbolEntry sym)
    {
        var mangled_maybe = GetMangledName(sym.Name, sym.Symbol.InternalTo);
        if (mangled_maybe != null)
            return mangled_maybe;

        string mangled;

        if (!sym.Attributes.HasAttribute("__no_mangle", out _))
        {
            var sb = new StringBuilder();
            // food prefix
            sb.Append("_$glbl$");

            // If internal
            if (sym.Symbol.InternalTo != null)
            {
                sb.Append(Path.GetFileNameWithoutExtension(sym.Symbol.InternalTo.Path));
                sb.Append('_');
            }

            sb.Append(sym.Name);
            mangled = sb.ToString();
        }
        else mangled = $"_{sym.Name}";
        SetMangledName(sym.Name, sym.Symbol.InternalTo, mangled);

        return mangled;
    }

    /// <summary>
    /// Computes the name of a function to be compatible in the resulting assembly.
    /// </summary>
    private string GetFunctionName(FunctionTree func)
    {
        var mangled_maybe = GetMangledName(func.Name, func.FuncSym.InternalTo);
        if (mangled_maybe != null)
            return mangled_maybe;

        var sym = func.FuncSym;
        string mangled;

        if (!func.AttributeClause.HasAttribute("__no_mangle", out _))
        {
            var sb = new StringBuilder();

            // food prefix
            sb.Append("_$func$");

            // If internal
            if (sym.InternalTo != null)
            {
                sb.Append(Path.GetFileNameWithoutExtension(sym.InternalTo.Path));
                sb.Append('_');
            }

            sb.Append(func.Name);
            mangled = sb.ToString();
        }
        else mangled = $"_{func.Name}";

        SetMangledName(func.Name, sym.InternalTo, mangled);
        return mangled;
    }

    /// <summary>
    /// Emits a function.
    /// </summary>
    /// <param name="func">The function to emit.</param>
    private void EmitFunction(FunctionTree func)
    {
        // stores the different rbp offsets to the variables and
        // parameters of the function.
        var var_param_storage = new Dictionary<(string, FType), int>();

        // Parameters
        var param_offset = 16; // skipping saved rbp and ret addr
        foreach (var param in func.Symbols)
        {
            var_param_storage.Add((param.Name, param.Symbol.Type!), param_offset);
            var aligned_size = ((int)param.Symbol.Type!.SizeOf() + (CompilerRunner.AlignmentRequired - 1)) & ~(CompilerRunner.AlignmentRequired - 1); // align
            param_offset += aligned_size;
        }

        // header
        var func_total_name = GetFunctionName(func);
        if (func.FuncSym.InternalTo == null)
            Emit($"\rglobal {func_total_name}");
        Emit($"\r{func_total_name}:");

        // Imperative-like structure generation
        if (func.Body!.Kind == StatementKind.Block)
        {
            // Variables!!!
            var var_offset = 0;
            var all_symbols = func.Body.RecursiveSymbols;
            var all_expr = func.Body.RecursiveExpressions;
            foreach (var v in all_symbols)
            {
                var T = v.Symbol.Type!;
                int tsz;
                if (T.Traits.HasFlag(TypeTraits.Array))
                    tsz = (int)(FType.VPTR.SizeOf() + FType.USZ.SizeOf());
                else tsz = (int)v.Symbol.Type!.SizeOf();
                var aligned_size = (tsz + (CompilerRunner.AlignmentRequired - 1)) & ~(CompilerRunner.AlignmentRequired - 1); // align
                var_offset -= aligned_size;
                var_param_storage.Add((v.Name, T), var_offset);
            }

            // Stack-allocated arrays!!!
            var all_arrays = all_expr.Where(e => e.Kind == ExpressionKind.CollectionInitialization);
            foreach (var a in all_arrays)
            {
                var aligned_size = ((int)a.Type!.SizeOf() + (CompilerRunner.AlignmentRequired - 1)) & ~(CompilerRunner.AlignmentRequired - 1);
                var_offset -= aligned_size;
                var_param_storage.Add(($"__array{a.Id}", a.Type!), var_offset);
            }

            // Stack-allocated structs (created by new)!!!
            var all_news = all_expr.Where(e => e.Kind == ExpressionKind.New);
            foreach (var @new in all_news)
            {
                // don't allocate if its an assign; that would be pointless
                if (((Expression)@new.Parent!).Kind == ExpressionKind.Assign)
                {
                    var assign_parent = (Expression)@new.Parent!;
                    var destination = assign_parent.GetChildrenExpressions().First();
                    var_param_storage.Add(
                        ($"__new{@new.Id}", @new.Type!),
                        var_param_storage[((string)destination.OperatorOrLiteral.Value!, @new.Type!)]);
                    continue;
                }
                var aligned_size = ((int)@new.Type!.SizeOf() + (CompilerRunner.AlignmentRequired - 1)) & ~(CompilerRunner.AlignmentRequired - 1);
                var_offset -= aligned_size;
                var_param_storage.Add(($"__new{@new.Id}", @new.Type!), var_offset);
            }

            // stack frame start
            Emit("push rbp");
            Emit("mov rbp, rsp");
            if (var_offset < 0)
                Emit($"sub rsp, {-var_offset}");

            // generate body
            var stmt_counter = 0;
            EmitStatement(var_param_storage, func.Body, null, null, ref stmt_counter);

            // return label used for returning
            // (with ck, return statements are jumps
            //  to the return label, which then cleans
            //  up before truly returning)
            Emit("\r.Return:");
            Emit("pop rbp");

            // incrementing rbp to delete arguments is
            // done by the callee in food
            if (param_offset - 16 > 0)
                Emit($"add rsp, {param_offset - 16}");

            Emit("ret");
        }
        else // expression body
        {
            EmitExpression(var_param_storage, func.Body.Expressions[0], NeedValue);
            EPop(func.Body.Expressions[0].Type!, MainRegister);
            Emit("ret");
        }

        Emit(""); // empty line
        _first_available_local_label = 0;
    }

    /// <summary>
    /// Emits a statement.
    /// </summary>
    private void EmitStatement(Dictionary<(string, FType), int> pv, Statement stmt, int? lleave_loop, int? literate_loop, ref int stmt_counter)
    {
        // labels are generated here (ik this is extremely bad but it works)

        var labels = stmt.FindNearestFunction()!.Labels;
        var nearest_switch = stmt.FindNearestSwitch();
        foreach (var label in labels)
            if (label.Index == stmt_counter)
                Emit($"\r._{label.Name}:");

        stmt_counter++;
        ////////////////////////////////////////////////////////////////////////////////

        switch (stmt.Kind)
        {
        case StatementKind.Error:
        case StatementKind.Empty:
            // do nothing
            return;

        case StatementKind.SwitchCase:
            Emit($"\r.__case{(nint)(decimal)stmt.Expressions[0].OperatorOrLiteral.Value!}{stmt.FindNearestSwitch()!.Id}:");
            return;

        case StatementKind.SwitchDefault:
            Emit($"\r.__default{stmt.FindNearestSwitch()!.Id}:");
            return;

        case StatementKind.Expression:
        case StatementKind.VariableInit:
        {
            var e = stmt.Expressions[0];
            EmitExpression(pv, e, NeedValue);

            // if the expression had a result, then make sure we don't
            // leave it lying around corrupting the stack
            //
            // this is still somewhat used by the push/pop optimizer pass
            if (e.Type! != FType.VOID)
                Emit($"pop {GetRegisterBySizeAndID(6, e.Type!.SizeOf())}");
            return;
        }

        // TODO: assert

        case StatementKind.Break:
            Emit($"jmp .L{lleave_loop}");
            return;

        case StatementKind.Continue:
            Emit($"jmp .L{literate_loop}");
            return;

        case StatementKind.Block: // note: variables are not implemented here, see function generation for that
            foreach (var s in stmt.Statements)
                EmitStatement(pv, s, lleave_loop, literate_loop, ref stmt_counter);
            return;

        case StatementKind.Sponge:
            Emit($"\r;<sponge start>");
            EmitStatement(pv, stmt.Statements[0], lleave_loop, literate_loop, ref stmt_counter);
            Emit($"\r;<sponge end>");
            return;

        case StatementKind.Return:
            // Void return
            if (stmt.Expressions.Count == 0)
            {
                Emit("jmp .Return");
                return;
            }

            // Compute return value
            EmitExpression(pv, stmt.Expressions[0], NeedValue);
            EPop(stmt.Expressions[0].Type!, MainRegister /* accumulator/return value */);
            Emit("jmp .Return");
            return;

        case StatementKind.If:
        {
            var then_label = NewLocalLabel();
            var lead_label = NewLocalLabel();

            // Generating the condition and checking it, then jumping if false
            EmitExpression(pv, stmt.Expressions[0], NeedValue);
            EPop(stmt.Expressions[0].Type!, MainRegister);
            Emit($"cmp {MainRegister(stmt.Expressions[0].Type!)}, 0");
            Emit($"jne .L{then_label}");

            // Else statement, if any.
            if (stmt.Statements.Count == 2)
                EmitStatement(pv, stmt.Statements[1], lleave_loop, literate_loop, ref stmt_counter);
            Emit($"jmp .L{lead_label}");

            // Then statement
            Emit($"\r.L{then_label}:");
            EmitStatement(pv, stmt.Statements[0], lleave_loop, literate_loop, ref stmt_counter);

            // Lead
            Emit($"\r.L{lead_label}:");
            return;
        }

        case StatementKind.While:
        {
            var iterate_label = NewLocalLabel();
            var leave_label = NewLocalLabel();

            // (iterate) check condition, jump to end if false
            Emit($"\r.L{iterate_label}:");
            EmitExpression(pv, stmt.Expressions[0], NeedValue);
            EPop(stmt.Expressions[0].Type!, MainRegister);
            Emit($"cmp {MainRegister(stmt.Expressions[0].Type!)}, 0");
            Emit($"je .L{leave_label}");

            // (body)
            EmitStatement(pv, stmt.Statements[0], leave_label, iterate_label, ref stmt_counter);
            Emit($"jmp .L{iterate_label}");

            // (leave)
            Emit($"\r.L{leave_label}:");
            return;
        }

        case StatementKind.DoWhile:
        {
            var iterate_label = NewLocalLabel();
            var leave_label = NewLocalLabel();
            var top_label = NewLocalLabel();

            // (top), beginning of body
            Emit($"\r.L{top_label}:");
            EmitStatement(pv, stmt.Statements[0], leave_label, iterate_label, ref stmt_counter);

            // (iterate) check condition, jump to top if true
            Emit($"\r.L{iterate_label}:");
            EmitExpression(pv, stmt.Expressions[0], NeedValue);
            EPop(stmt.Expressions[0].Type!, MainRegister);
            Emit($"cmp {MainRegister(stmt.Expressions[0].Type!)}, 0");
            Emit($"jne .L{top_label}");

            // (leave)
            Emit($"\r.L{leave_label}:");
            return;
        }

        case StatementKind.For:
        {
            var top_label = NewLocalLabel();
            var iterate_label = NewLocalLabel();
            var leave_label = NewLocalLabel();

            // initialize (if present)
            if (stmt.Statements.Count > 1)
                EmitStatement(pv, stmt.Statements[0], null, null, ref stmt_counter); // varinit stmt

            // condition
            var iterate_cond = stmt.Expressions[0];
            Emit($"\r.L{top_label}:");
            EmitExpression(pv, stmt.Expressions[0], NeedValue);
            EPop(iterate_cond.Type!, MainRegister);
            Emit($"cmp {MainRegister(iterate_cond.Type!)}, 0");
            Emit($"je .L{leave_label}");

            // body
            EmitStatement(pv, stmt.Statements[stmt.Statements.Count - 1], leave_label, iterate_label, ref stmt_counter);

            // iterate
            Emit($"\r.L{iterate_label}:");
            EmitExpression(pv, stmt.Expressions[1], NeedValue);
            Emit($"jmp .L{top_label}");

            // (leave)
            Emit($"\r.L{leave_label}:");
            return;
        }

        case StatementKind.Goto:
            // computed goto
            if (stmt.Expressions.Count > 0)
            {
                EmitExpression(pv, stmt.Expressions[0], NeedValue);
                EPop(FType.VPTR, MainRegister);
                Emit($"jmp {MainRegister(FType.VPTR)}");
            }
            else // standard goto
                Emit($"jmp ._{(string)stmt.Objects[0]}");
            break;

        case StatementKind.Switch:
        {
            var non_nested = stmt.AllStatementsExcept(StatementKind.Switch); // skipping switches
            var cases = non_nested.Where(s => s.Kind == StatementKind.SwitchCase);
            var @default = non_nested.Where(s => s.Kind == StatementKind.SwitchDefault).SingleOrDefault();

            var jump_table_label = NewLocalLabel();
            var leave_label = NewLocalLabel();

            // jump to jump table
            Emit($"jmp .L{jump_table_label}");

            // body is generated first
            EmitStatement(pv, stmt.Statements[0], leave_label, null, ref stmt_counter);

            // evaluation
            var eval_type = stmt.Expressions[0].Type!;
            Emit($"\r.L{jump_table_label}:");
            EmitExpression(pv, stmt.Expressions[0], NeedValue);
            EPop(eval_type, MainRegister);

            // bound check
            var highest_bound
                = (nint)cases
                .Select(s => s.Expressions[0])
                .Sum(e => (decimal)e.OperatorOrLiteral.Value!);

            // do checks
            foreach (var @case in cases)
            {
                var match = (nint)(decimal)@case.Expressions[0].OperatorOrLiteral.Value!;
                Emit($"cmp {MainRegister(eval_type)}, {match}");
                Emit($"je __case{match}{stmt.Id}");
            }

            // all checks failed; leave or jump to default
            if (@default is not null)
                Emit($"jmp __default{stmt.Id}");

            // (leave)
            Emit($"\r.L{leave_label}:");

            return;
        }

        default:
            throw new NotImplementedException();

        }
    }

    // =====================================================================

    /// <summary>
    /// Emits a constant string.
    /// </summary>
    /// <param name="str">The string to emit.</param>
    private int EmitConstString(string str)
    {
        var id = _first_available_conststr_id++;

        _string_pool_output.AppendLine($".S{id}:");
        _string_pool_output.AppendLine($"\tdb `{Escapize(str)}`");
        _string_pool_output.AppendLine($"\tdb 0");

        return id;
    }

    /// <summary>
    /// Allocates a label, without generating any code.
    /// </summary>
    private int NewLocalLabel() => _first_available_local_label++;

    private string WordSize(FType T) => T.Size switch
    {
        1 => "byte",
        2 => "word",
        4 => "dword",
        _ => "qword",
    };

    /// <summary>
    /// Returns the register required for the given type.
    /// TODO: floats
    /// </summary>
    private string MainRegister(FType T) => T.Size switch
    {
        1 => "al",
        2 => "ax",
        4 => "eax",
        _ => "rax",
    };

    /// <summary>
    /// Returns the second register required for the given type.
    /// TODO: floats
    /// </summary>
    private string SecondRegister(FType T) => T.Size switch
    {
        1 => "dl",
        2 => "dx",
        4 => "edx",
        _ => "rdx",
    };

    /// <summary>
    /// Returns the third register required for the given type.
    /// TODO: floats
    /// </summary>
    private string ThirdRegister(FType T) => T.Size switch
    {
        1 => "bl",
        2 => "bx",
        4 => "ebx",
        _ => "rbx",
    };

    /// <summary>
    /// Emits a push instruction.
    /// </summary>
    /// <param name="T">The type to push.</param>
    /// <param name="op">The operand.</param>
    private void EPush(FType T, string op) => Emit(GetSizeFromRegister(op) != 0 ? $"push {op}" : $"push {WordSize(T)} {op}");
    private void EPop(FType T,  Func<FType, string> register) => Emit($"pop {register.Invoke(T)}");

    /// <summary>
    /// Emits an expression.
    /// </summary>
    /// <param name="e">The expression to generate.</param>
    /// <param name="va_status">Whether a value or an address should be read from the expression.</param>
    public void EmitExpression(Dictionary<(string, FType), int> pv, Expression e, int va_status)
    {
        switch (e.Kind)
        {
        case ExpressionKind.Literal:
            if (e.Type == FType.STRING)
            {
                var sid = EmitConstString((string)e.OperatorOrLiteral.Value!);
                EPush(FType.STRING, $".S{sid}");
                goto Return;
            }

            EPush(e.Type!, $"{e.OperatorOrLiteral.Value!}");
            goto Return;

        case ExpressionKind.Identifier:
        {
            var identifier = (string)e.OperatorOrLiteral.Value!;
            string addr;

            // Variable or param!!!
            if (pv.ContainsKey((identifier, e.Type!)))
            {
                var offset = pv[(identifier, e.Type!)];
                addr = $"[rbp{(offset < 0 ? "" : "+")}{offset}]";
                if (va_status == NeedValue) // push value
                    EPush(e.Type!, addr);
                else // push addr
                {
                    Emit($"lea {MainRegister(FType.VPTR)}, {addr}");
                    EPush(e.Type!, MainRegister(FType.VPTR));
                }
                goto Return;
            }

            // assuming identifier is valid
            var glbl_name = GetMangledName(identifier, InternalBearsName(identifier) ? e.OperatorOrLiteral.Source : null);
            addr = glbl_name!;
            if (va_status == NeedValue)
                EPush(e.Type!, addr);
            else // push addr
            {
                Emit($"lea {MainRegister(FType.VPTR)}, {addr}");
                EPush(e.Type!, MainRegister(FType.VPTR));
            }

            goto Return;
        }

        case ExpressionKind.Cast:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedValue);
            if (e.Type!.Traits.HasFlag(TypeTraits.Unsigned)
                && left.Type!.Traits.HasFlag(TypeTraits.Unsigned))
            {
                if (e.Type!.Size <= left.Type!.Size)
                {
                    EPop(left.Type!, MainRegister);
                    EPush(e.Type!, MainRegister(e.Type!));
                }

                EPop(left.Type!, SecondRegister);
                Emit($"movzx {MainRegister(e.Type!)}, {SecondRegister(left.Type!)}");
                EPush(e.Type!, MainRegister(e.Type!));
                goto Return;
            }

            // TODO: floats
            if (e.Type! == FType.BOOL)
            {
                EPop(left.Type!, MainRegister);
                Emit($"cmp {MainRegister(left.Type!)}, 0");
                Emit($"setne {MainRegister(e.Type!)}");
                EPush(e.Type!, MainRegister(e.Type!));
                goto Return;
            }

            if (e.Type!.Size <= left.Type!.Size)
            {
                EPop(left.Type!, MainRegister);
                EPush(e.Type!, MainRegister(e.Type!));
            }

            EPop(left.Type!, SecondRegister);
            Emit($"movsx {MainRegister(e.Type!)}, {SecondRegister(left.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.PostfixIncrement:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedAddress);

            // pop address into second register
            EPop(left.Type!, SecondRegister);

            // load value from address into main register & push
            Emit($"mov {MainRegister(e.Type!)}, [{SecondRegister(left.Type!)}]");
            EPush(e.Type!, MainRegister(e.Type!));

            // increment and load back into address
            Emit($"inc {MainRegister(e.Type!)}");
            Emit($"mov {WordSize(e.Type!)} [{SecondRegister(left.Type!)}], {MainRegister(e.Type!)}");
            goto Return;
        }

        case ExpressionKind.PostfixDecrement:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedAddress);

            // pop address into second register
            EPop(left.Type!, SecondRegister);

            // load value from address into main register & push
            Emit($"mov {MainRegister(e.Type!)}, [{SecondRegister(left.Type!)}]");
            EPush(e.Type!, MainRegister(e.Type!));

            // increment and load back into address
            Emit($"dec {MainRegister(e.Type!)}");
            Emit($"mov {WordSize(e.Type!)} [{SecondRegister(left.Type!)}], {MainRegister(e.Type!)}");
            goto Return;
        }

        case ExpressionKind.ArraySubscript:
        {
            var ptr = e.GetChildrenExpressions().ElementAt(0);
            var index = e.GetChildrenExpressions().ElementAt(1);

            // computing shift required to multiply by size
            // TODO: support traditional multiplication & user types
            var elem_size = ((ArraySubjugateSignature)ptr.Type!.SubjugateSignature!).ObjectType.Size;
            var shifts_required = Math.Log2(elem_size);
            Contract.Assert(shifts_required == (int)shifts_required);

            EmitExpression(pv, ptr, NeedValue);
            EmitExpression(pv, index, NeedValue);

            // pop ptr and index, add
            EPop(index.Type!, SecondRegister);
            EPop(ptr.Type!, MainRegister);
            Emit($"sal {SecondRegister(index.Type!)}, {shifts_required}");
            if (ptr.Type!.Size > index.Type!.Size)
                Emit($"movzx {SecondRegister(ptr.Type!)}, {SecondRegister(index.Type!)}");
            Emit($"add {MainRegister(ptr.Type!)}, {SecondRegister(ptr.Type!)}");

            // push addr
            if (va_status == NeedAddress)
            {
                EPush(ptr.Type!, MainRegister(ptr.Type!));
                goto Return;
            }

            // push value
            Emit($"mov {MainRegister(e.Type!)}, [{MainRegister(ptr.Type!)}]");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.FunctionCall:
        {
            var func = e.GetChildrenExpressions().ElementAt(0);
            var args = e.GetChildrenExpressions().Skip(1);

            // put the function into the main register
            EmitExpression(pv, func, NeedValue);
            EPop(FType.VPTR, MainRegister);

            // emit and push arguments in reverse order
            // TODO: in/out/varying
            for (var i = args.Count() - 1; i >= 0; i--)
            {
                var arg = args.ElementAt(i);
                var argtype = arg.Type!;
                var argsize = argtype.SizeOf();
                EmitExpression(pv, arg, NeedValue);
                var argsize_aligned
                    = ((int)argsize + (CompilerRunner.AlignmentRequired - 1)) & ~(CompilerRunner.AlignmentRequired - 1); // align

                // alignment
                if (argsize_aligned != argtype.SizeOf())
                    Emit($"sub rsp, {argsize_aligned - argsize}");
            }
            Emit($"call {MainRegister(FType.VPTR)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        // TODO: member access

        case ExpressionKind.PrefixIncrement:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedAddress);

            // pop address into second register
            EPop(left.Type!, SecondRegister);

            // load value from address into main register & increment
            Emit($"mov {MainRegister(e.Type!)}, [{SecondRegister(left.Type!)}]");
            Emit($"inc {MainRegister(e.Type!)}");

            // push and load value back into address
            EPush(e.Type!, MainRegister(e.Type!));
            Emit($"mov {WordSize(e.Type!)} [{SecondRegister(left.Type!)}], {MainRegister(e.Type!)}");
            goto Return;
        }

        case ExpressionKind.PrefixDecrement:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedAddress);

            // pop address into second register
            EPop(left.Type!, SecondRegister);

            // load value from address into main register & increment
            Emit($"mov {MainRegister(e.Type!)}, [{SecondRegister(left.Type!)}]");
            Emit($"dec {MainRegister(e.Type!)}");

            // push and load value back into address
            EPush(e.Type!, MainRegister(e.Type!));
            Emit($"mov {WordSize(e.Type!)} [{SecondRegister(left.Type!)}], {MainRegister(e.Type!)}");
            goto Return;
        }

        case ExpressionKind.UnaryPlus:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            // preserve
            EmitExpression(pv, left, NeedValue);
            goto Return;
        }

        case ExpressionKind.UnaryMinus:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedValue);
            EPop(e.Type!, MainRegister);
            Emit($"neg {MainRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.LogicalNot:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedValue);
            EPop(e.Type!, MainRegister);
            Emit($"cmp {MainRegister(e.Type!)}, 0");
            Emit($"sete {MainRegister(FType.I8)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.BitwiseNot:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedValue);
            EPop(e.Type!, MainRegister);
            Emit($"not {MainRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.Dereference:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            EmitExpression(pv, left, NeedValue);

            // Reading value
            // If we need the address, we simply skip and
            // preserve the stack top
            if (va_status == NeedValue)
            {
                EPop(left.Type!, SecondRegister);
                Emit($"mov {MainRegister(e.Type!)}, [{SecondRegister(left.Type!)}]");
                EPush(e.Type!, MainRegister(e.Type!));
            }
            goto Return;
        }

        case ExpressionKind.AddressOf:
        case ExpressionKind.OpaqueAddressOf:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            if (left.IsLabelRef)
            {
                var label_name = (string)left.OperatorOrLiteral.Value!;
                EPush(e.Type!, "._" + label_name);
            }
            else
            {
                EmitExpression(pv, left, NeedAddress);
                // simply preserve stack top; it contains the address
            }
            goto Return;
        }

        case ExpressionKind.Multiply:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left
            if (e.Type!.Traits.HasFlag(TypeTraits.Unsigned))
                Emit($"mul {MainRegister(e.Type!)}, {SecondRegister(e.Type!)}");
            else Emit($"imul {MainRegister(e.Type!)}, {SecondRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.Divide:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left

            Emit($"cqo");
            if (e.Type!.Traits.HasFlag(TypeTraits.Unsigned))
                Emit($"div {SecondRegister(e.Type!)}");
            else Emit($"idiv {SecondRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.Modulo:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left

            Emit($"cqo");
            if (e.Type!.Traits.HasFlag(TypeTraits.Unsigned))
                Emit($"div {SecondRegister(e.Type!)}");
            else Emit($"idiv {SecondRegister(e.Type!)}");
            EPush(e.Type!, SecondRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.Add:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left
            Emit($"add {MainRegister(e.Type!)}, {SecondRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.Subtract:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left
            Emit($"sub {MainRegister(e.Type!)}, {SecondRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.LeftShift:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left
            Emit($"sal {MainRegister(e.Type!)}, {SecondRegister(FType.U8)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.RightShift:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left
            Emit($"sar {MainRegister(e.Type!)}, {SecondRegister(FType.U8)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.Lower:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(left.Type!, SecondRegister); // right
            EPop(left.Type!, MainRegister);   // left
            Emit($"cmp {MainRegister(left.Type!)}, {SecondRegister(left.Type!)}");
            Emit($"setl {MainRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.Greater:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(left.Type!, SecondRegister); // right
            EPop(left.Type!, MainRegister);   // left
            Emit($"cmp {MainRegister(left.Type!)}, {SecondRegister(left.Type!)}");
            Emit($"setg {MainRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.LowerEqual:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(left.Type!, SecondRegister); // right
            EPop(left.Type!, MainRegister);   // left
            Emit($"cmp {MainRegister(left.Type!)}, {SecondRegister(left.Type!)}");
            Emit($"setle {MainRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.GreaterEqual:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(left.Type!, SecondRegister); // right
            EPop(left.Type!, MainRegister);   // left
            Emit($"cmp {MainRegister(left.Type!)}, {SecondRegister(left.Type!)}");
            Emit($"setge {MainRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        // TODO: *memberof

        case ExpressionKind.Equal:
        {
            if (e.Type!.Traits.HasFlag(TypeTraits.Members)
                || e.Type!.Traits.HasFlag(TypeTraits.Array))
                throw new NotImplementedException();

            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(left.Type!, SecondRegister); // right
            EPop(left.Type!, MainRegister);   // left
            Emit($"cmp {MainRegister(left.Type!)}, {SecondRegister(left.Type!)}");
            Emit($"sete {MainRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.NotEqual:
        {
            if (e.Type!.Traits.HasFlag(TypeTraits.Members)
                || e.Type!.Traits.HasFlag(TypeTraits.Array))
                throw new NotImplementedException();

            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(left.Type!, SecondRegister); // right
            EPop(left.Type!, MainRegister);   // left
            Emit($"cmp {MainRegister(left.Type!)}, {SecondRegister(left.Type!)}");
            Emit($"setne {MainRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.BitwiseAnd:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left
            Emit($"and {MainRegister(e.Type!)}, {SecondRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.BitwiseOr:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left
            Emit($"or {MainRegister(e.Type!)}, {SecondRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.BitwiseXOr:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left
            Emit($"xor {MainRegister(e.Type!)}, {SecondRegister(e.Type!)}");
            EPush(e.Type!, MainRegister(e.Type!));
            goto Return;
        }

        case ExpressionKind.LogicalAnd:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left

            var lfalse = NewLocalLabel();
            var lend = NewLocalLabel();

            // checking if any are false, then jump to false
            Emit($"cmp {MainRegister(e.Type!)}, 0");
            Emit($"je .L{lfalse}");
            Emit($"cmp {SecondRegister(e.Type!)}, 0");
            Emit($"je .L{lfalse}");

            // if true, push true and jump to end
            EPush(e.Type!, "1");
            Emit($"jmp .L{lend}");

            // false: push false
            Emit($"\r.L{lfalse}:");
            EPush(e.Type!, "0");

            // (end)
            Emit($"\r.L{lend}:");
            goto Return;
        }

        case ExpressionKind.LogicalOr:
        {
            var left = e.GetChildrenExpressions().ElementAt(0);
            var right = e.GetChildrenExpressions().ElementAt(1);
            EmitExpression(pv, left, NeedValue);
            EmitExpression(pv, right, NeedValue);
            EPop(e.Type!, SecondRegister); // right
            EPop(e.Type!, MainRegister);   // left

            var ltrue = NewLocalLabel();
            var lend = NewLocalLabel();

            // checking if any are true, then jump to true
            Emit($"cmp {MainRegister(e.Type!)}, 0");
            Emit($"jne .L{ltrue}");
            Emit($"cmp {SecondRegister(e.Type!)}, 0");
            Emit($"jne .L{ltrue}");

            // if false, push false and jump to end
            EPush(e.Type!, "0");
            Emit($"jmp .L{lend}");

            // false: push false
            Emit($"\r.L{ltrue}:");
            EPush(e.Type!, "1");

            // (end)
            Emit($"\r.L{lend}:");
            goto Return;
        }

        case ExpressionKind.Conditional:
        {
            var cond = e.GetChildrenExpressions().ElementAt(0);
            var vtrue = e.GetChildrenExpressions().ElementAt(1);
            var vfalse = e.GetChildrenExpressions().ElementAt(2);

            var ltrue = NewLocalLabel();
            var lend = NewLocalLabel();

            // Evaluate condition, jump to true if, well, true
            EmitExpression(pv, cond, NeedValue);
            Emit($"cmp {MainRegister(cond.Type!)}, 0");
            Emit($"jne .L{ltrue}");

            // Lead is if the condition failed
            EmitExpression(pv, vfalse, NeedValue);
            // (preserve)
            Emit($"jmp .L{lend}");

            // If true, compute true branch
            Emit($"\r.L{ltrue}:");
            EmitExpression(pv, vtrue, NeedValue);
            // (preserve)

            // Lead
            Emit($"\r.L{lend}:");
            goto Return;
        }

        case ExpressionKind.Assign:
        case ExpressionKind.VariableInit:
        {
            var destination = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            // for structs, use memcpy
            if (source.Type!.Traits.HasFlag(TypeTraits.Members))
            {
                EmitExpression(pv, destination, NeedAddress);
                EmitExpression(pv, source, NeedValue); // address
                EPop(FType.VPTR, SecondRegister); // source
                EPop(FType.VPTR, MainRegister);   // destination
                // TODO: call #{externc} __memcpy(*void, *void, usz): void
            }
            else
            {
                EmitExpression(pv, destination, NeedAddress);
                EmitExpression(pv, source, NeedValue);
                EPop(source.Type!, SecondRegister); // source
                EPop(FType.VPTR, MainRegister); // destination
                Emit($"mov {WordSize(FType.VPTR)} [{MainRegister(FType.VPTR)}], {SecondRegister(source.Type!)}");
            }
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignSum:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, MainRegister); // destination
            Emit($"add {WordSize(FType.VPTR)} [{MainRegister(FType.VPTR)}], {SecondRegister(source.Type!)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignDiff:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, MainRegister); // destination
            Emit($"sub {WordSize(FType.VPTR)} [{MainRegister(FType.VPTR)}], {SecondRegister(source.Type!)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignProduct:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, ThirdRegister); // destination
            Emit($"mov {MainRegister(accumulator.Type!)}, [{ThirdRegister(FType.VPTR)}]");
            if (accumulator.Type!.Traits.HasFlag(TypeTraits.Unsigned))
                Emit($"mul {MainRegister(accumulator.Type!)}, {SecondRegister(source.Type!)}");
            else Emit($"imul {MainRegister(accumulator.Type!)}, {SecondRegister(source.Type!)}");
            Emit($"mov {WordSize(accumulator.Type!)} [{ThirdRegister(FType.VPTR)}], {MainRegister(accumulator.Type!)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignQuotient:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, ThirdRegister); // destination
            Emit($"mov {MainRegister(accumulator.Type!)}, [{ThirdRegister(FType.VPTR)}]");
            if (accumulator.Type!.Traits.HasFlag(TypeTraits.Unsigned))
                Emit($"div {SecondRegister(source.Type!)}");
            else Emit($"idiv {SecondRegister(source.Type!)}");
            Emit($"mov {WordSize(accumulator.Type!)} [{ThirdRegister(FType.VPTR)}], {MainRegister(accumulator.Type!)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignRemainder:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, ThirdRegister); // destination
            Emit($"mov {MainRegister(accumulator.Type!)}, [{ThirdRegister(FType.VPTR)}]");
            if (accumulator.Type!.Traits.HasFlag(TypeTraits.Unsigned))
                Emit($"div {SecondRegister(source.Type!)}");
            else Emit($"idiv {SecondRegister(source.Type!)}");
            Emit($"mov {WordSize(accumulator.Type!)} [{ThirdRegister(FType.VPTR)}], {SecondRegister(accumulator.Type!)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignBitwiseAnd:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, MainRegister); // destination
            Emit($"and {WordSize(FType.VPTR)} [{MainRegister(FType.VPTR)}], {SecondRegister(source.Type!)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignBitwiseXOr:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, MainRegister); // destination
            Emit($"xor {WordSize(FType.VPTR)} [{MainRegister(FType.VPTR)}], {SecondRegister(source.Type!)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignBitwiseOr:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, MainRegister); // destination
            Emit($"or {WordSize(FType.VPTR)} [{MainRegister(FType.VPTR)}], {SecondRegister(source.Type!)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignLeftShift:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, MainRegister); // destination
            Emit($"sal {WordSize(FType.VPTR)} [{MainRegister(FType.VPTR)}], {SecondRegister(FType.U8)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.AssignRightShift:
        {
            var accumulator = e.GetChildrenExpressions().ElementAt(0);
            var source = e.GetChildrenExpressions().ElementAt(1);

            EmitExpression(pv, accumulator, NeedAddress);
            EmitExpression(pv, source, NeedValue);
            EPop(source.Type!, SecondRegister); // source
            EPop(FType.VPTR, MainRegister); // destination
            Emit($"sar {WordSize(FType.VPTR)} [{MainRegister(FType.VPTR)}], {SecondRegister(FType.U8)}");
            // (void)
            goto Return;
        }

        case ExpressionKind.CollectionInitialization:
        {
            var initializer_list = e.GetChildrenExpressions();
            var count = initializer_list.Count();
            var base_address = (nint)pv[($"__array{e.Id}", e.Type!)];
            
            // same as address_full, although unchanged by iteration
            var return_address = $"[rbp{(base_address < 0 ? "" : "+")}{base_address}]";
            for (var i = 0; i < count; i++)
            {
                var address_full = $"[rbp{(base_address < 0 ? "" : "+")}{base_address}]";
                var current = initializer_list.ElementAt(i);
                EmitExpression(pv, current, NeedValue);
                Emit($"pop {WordSize(current.Type!)} {address_full}");
                base_address += current.Type!.SizeOf();
            }
            EPush(FType.VPTR, return_address);
            // TODO: push length
            break;
        }

        // TODO: lengthof

        case ExpressionKind.New:
        {
            var initializer_list = e.GetChildrenExpressions();
            var count = initializer_list.Count();
            var base_address = (nint)pv[($"__new{e.Id}", e.Type!)];

            // TODO: call #{externc} __zeroblock(*void, usz): void

            // same as address_full, although unchanged by iteration
            var return_address = $"[rbp{(base_address < 0 ? "" : "+")}{base_address}]";
            for (var i = 0; i < count; i++)
            {
                var address_full = $"[rbp{(base_address < 0 ? "" : "+")}{base_address}]";
                var current = initializer_list.ElementAt(i);
                EmitExpression(pv, current, NeedValue);
                Emit($"pop {WordSize(current.Type!)} {address_full}");
                base_address += current.Type!.SizeOf();
            }
            EPush(FType.VPTR, return_address);
            break;
        }

        default: throw new NotImplementedException();

        }

    Return:
        Emit("");
        return;

    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////

    /// <summary>
    /// Optimizes pushes followed by pops by turning them into MOVs or variants.
    /// </summary>
    public void OptimizePushAndPops()
    {
        while (PassOptimizePushAndPops() != 0) ;
        ExpandPushAndPop();
    }

    /// <summary>
    /// Optimizes pushes followed by pops by turning them into MOVs or variants.
    /// </summary>
    /// <returns>The amount of push/pop structures optimized.</returns>
    private int PassOptimizePushAndPops()
    {
        var optimized = 0;

        // get all lines, get rid of comments
        var lines = (IEnumerable<string>)_output.ToString().Split("\n", StringSplitOptions.RemoveEmptyEntries);
        lines = lines.Where(l => !(l.StartsWith(';') || string.IsNullOrWhiteSpace(l)));
        var lines_length = lines.Count();

        // worst case scenario, we don't do any optimizing
        // (extremely unlikely)
        var output = new List<string>();

        for (var i = 0; i < lines_length; i += 2)
        {
            // +-------+-------------------------+
            // | Index | [0     ] [1     ] [2  ] |
            // | Entry | push/pop wordsize value |
            // +-------+-------------------------+
            // we discard `wordsize` when `value` is
            // a register

            var current_line // push
                = lines.ElementAt(i)
                .Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            var next_line // pop
                = (i + 1 < lines_length ? lines.ElementAt(i + 1) : string.Empty)
                .Split(' ', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

            string destination, source;
            nint destination_size, source_size;

            // TODO: mov optimizations (not necessary but would be a nice convenience feature)
            //
            // turn:
            // mov rax, dword [rbp-4]
            // mov rbx, rax
            ////////// into
            // mov rbx, dword [rbp-4]

            if (current_line[0] != "push" || next_line[0] != "pop")
            {
                // discard
                output.Add(lines.ElementAt(i));
                i--;
                continue;
            }

            // pop
            destination = lines.ElementAt(i + 1).Contains("word") || lines.ElementAt(i + 1).Contains("byte")
                ? next_line.TakeLast(2).Aggregate((a, b) => $"{a} {b}")
                : next_line.Last();

            // push
            source = lines.ElementAt(i).Contains("word") || lines.ElementAt(i).Contains("byte")
                ? current_line.TakeLast(2).Aggregate((a, b) => $"{a} {b}")
                : current_line.Last();

            // these might not be necessarily registers, and we
            // must be ready to face the eventually of a registerless
            // mov, which is an invalid opcode ¯\_(ツ)_/¯
            destination_size = GetSizeFromRegister(destination);
            source_size = GetSizeFromRegister(source);

            if (destination == source)
            { } // discard the two lines
            else if (destination_size == 0 && source_size == 0)
            {
                var swap_reg = GetRegisterBySizeAndID(2, SizeFromWordsizeStr(current_line[1]));
                output.Add($"\tmov {swap_reg}, {source}");
                output.Add($"\tmov {destination}, {swap_reg}");
                optimized++;
            }
            else
            {
                output.Add($"\tmov {destination}, {source}");
                optimized++;
            }
        }

        // casually pop that in
        _output.Clear();
        _output.Append(output.Aggregate(string.Empty, (a, b) => $"{a}\n{b}"));

        return optimized;
    }

    private void ExpandPushAndPop()
    {
        // get all lines, get rid of comments
        var lines = (IEnumerable<string>)_output.ToString().Split("\n", StringSplitOptions.RemoveEmptyEntries);
        lines = lines.Where(l => !(l.StartsWith(';') || string.IsNullOrWhiteSpace(l)));
        var lines_length = lines.Count();

        // worst case scenario, we don't do any optimizing
        // (extremely unlikely)
        var output = new List<string>();

        foreach (var line in lines)
        {
            var current_line = line.Split(new[] { ' ' }, 2, StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            if (current_line[0] == "push")
            {
                var regsize = GetSizeFromRegister(current_line.Last());
                if (regsize == 8)
                {
                    output.Add(line);
                    continue;
                }

                output.Add($"\tsub rsp, {regsize}");
                output.Add($"\tmov [rsp], {current_line.Last()}");
                continue;
            }
            else if (current_line[0] == "pop")
            {
                var regsize = GetSizeFromRegister(current_line.Last());
                if (regsize == 8)
                {
                    output.Add(line);
                    continue;
                }

                output.Add($"\tmov {current_line.Last()}, [rsp]");
                output.Add($"\tadd rsp, {regsize}");
                continue;
            }

            output.Add(line);
        }

        // casually pop that in (p.2)
        _output.Clear();
        _output.Append(output.Aggregate(string.Empty, (a, b) => $"{a}\n{b}"));
    }

    private nint SizeFromWordsizeStr(string wordsize)
    {
        if (wordsize.StartsWith("byte"))
            return 1;
        else if (wordsize.StartsWith("word"))
            return 2;
        else if (wordsize.StartsWith("dword"))
            return 4;
        else if (wordsize.StartsWith("qword"))
            return 8;

        throw new NotImplementedException();
    }

    private string GetRegisterBySizeAndID(int id, nint size)
    {
        var size_address = (int)Math.Floor(Math.Log2(size)); // magic
        return _registers[id, size_address];
    }

    public nint GetSizeFromRegister(string name)
    {
        for (var y = 0; y <= _registers.GetUpperBound(0); y++)
        {
            for (var x = 0; x <= _registers.GetUpperBound(1); x++)
            {
                var reg = _registers[y, x];
                if (reg == name)
                    return (nint)Math.Pow(2, x);
            }
        }

        return 0;
    }

    /// <summary>
    /// 0 = accumulator/data 0 (ax)<br/>
    /// 1 = data 1 (bx)<br/>
    /// 2 = counter (cx)<br/>
    /// 3 = data 2 (dx)<br/>
    /// 4 = sdata 0 (si)<br/>
    /// 5 = sdata 1 (di)<br/>
    /// 6 = data 3 (r8)<br/>
    /// 7 = data 4 (r9)<br/>
    /// 8 = data 5 (r10)<br/>
    /// 9 = data 6 (r11)<br/>
    /// 10 = data 7 (r12)<br/>
    /// 11 = data 8 (r13)<br/>
    /// 12 = data 9 (r14)<br/>
    /// 13 = data 10 (r15)<br/>
    /// </summary>
    private readonly string[,] _registers =
    {
        { "al", "ax", "eax", "rax" },
        { "bl", "bx", "ebx", "rbx" },
        { "cl", "cx", "ecx", "rcx" },
        { "dl", "dx", "edx", "rdx" },

        { "sil", "si", "esi", "rsi" },
        { "dil", "di", "edi", "rdi" },

        { "r8b",  "r8w",  "r8d",  "r8" },
        { "r9b",  "r9w",  "r9d",  "r9" },
        { "r10b", "r10w", "r10d", "r10" },
        { "r11b", "r11w", "r11d", "r11" },
        { "r12b", "r12w", "r12d", "r12" },
        { "r13b", "r13w", "r13d", "r13" },
        { "r14b", "r14w", "r14d", "r14" },
        { "r15b", "r15w", "r15d", "r15" },
    };
}
